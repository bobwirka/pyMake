# pyMake Application Documentation

### Generated by ChatGPT...amazingly close

## Overview

The `pyMake` application is a Python-based build automation tool that uses an XML configuration file to define the structure and settings of a software project. It handles variable substitutions, conditional processing, prebuild and postbuild operations, and recursive project builds. It is designed to be flexible, allowing for complex build configurations and dependency management.

## Table of Contents
1. [Application Structure](#application-structure)
2. [Key Components](#key-components)
    - [Global Variables](#global-variables)
    - [Core Functions](#core-functions)
    - [Classes](#classes)
3. [Application Workflow](#application-workflow)
4. [XML Configuration](#xml-configuration)
5. [Command-Line Options](#command-line-options)
6. [Variable Substitution and Conditional Logic](#variable-substitution-and-conditional-logic)
7. [Error Handling](#error-handling)
8. [Extending the Application](#extending-the-application)
9. [Examples](#examples)
10. [Conclusion](#conclusion)

## Application Structure

The `pyMake` application is composed of several key components, including global variables, core functions, and classes. These components work together to parse the XML configuration file, perform variable substitutions, evaluate conditional logic, and execute build commands.

### Files
- `pyMake.py`: Main application file that contains all the logic and entry point for execution.

## Key Components

### Global Variables

- **`printIntermediateXml`**: Controls whether intermediate XML files are printed during processing. Useful for debugging.
- **`cwd_main`**: Stores the current working directory at the time of execution.
- **`varSubDict`**: Global dictionary used for variable substitutions throughout the build process.
- **`gError`**: Global variable used to indicate critical errors during processing.

### Core Functions

1. **`parseFile(filePath)`**: Parses the given XML file and returns the parsed tree and root element. Handles errors gracefully.
   
2. **`getVarSub(match, required=True)`**: Retrieves the value for a given variable from the `varSubDict` dictionary. Raises an error if the variable is required but not found.

3. **`varSub(expression, required=True)`**: Performs variable substitution on the given expression, replacing `{key}` patterns with their corresponding values from the `varSubDict`.

4. **`addDict(varDict, child, required)`**: Adds a single `<dict>` element to the variable dictionary, handling `if` attributes for conditional inclusion.

5. **`addDicts(varDict, ele, required=False)`**: Recursively processes and adds `<dict>` elements from the XML file to the variable dictionary.

6. **`replace_vars()`**: Iterates through `varSubDict` and replaces all `{key}` patterns with the corresponding values, ensuring all variables are fully resolved.

7. **`checkIfElement(ele, required=False)`**: Evaluates the `if` attribute of an XML element and returns a boolean indicating if the element should be included.

8. **`replaceKeys(ele, required=True)`**: Recursively replaces keys in an XML element and its children, performing variable substitution.

9. **`processIfAttributes(element)`**: Processes `if` attributes for all elements, marking those that evaluate to `False` as `culled`.

10. **`GetConfigAndToolchain(eleRoot, config)`**: Finds and returns the appropriate `<configuration>` and `<toolchain>` elements for the given configuration name.

### Classes

1. **`Flags`**: Manages different compiler and linker flags for assembly, C, C++, and common configurations. Handles variable substitutions within flags.

2. **`PreBuild`**: Represents a prebuild project, encapsulating configuration details and dependencies for recursive building.

3. **`SourceFile`**: Represents a source file in the build process. Determines file type, tracks dependencies, and manages specific compiler flags.

4. **`Config`**: Encapsulates the build configuration, including flags, includes, libraries, and source files. Handles toolchain verification and configuration-specific settings.

5. **`Build`**: The core class that orchestrates the entire build process. Manages parsing, configuration, source file handling, and the execution of build commands.

## Application Workflow

1. **Initialization**: The application starts by parsing command-line arguments and locating the XML configuration file. It changes to the directory containing the file and sets up global variables.

2. **Parsing XML Configuration**: The XML file is parsed, and initial dictionary values are added based on command-line substitutions and included XML `<dict>` files.

3. **Prebuild Operations**: If prebuilds are enabled, dependent projects are built recursively before proceeding with the main project.

4. **Configuration and Toolchain Setup**: The appropriate `<configuration>` and `<toolchain>` elements are selected based on the specified configuration. All elements with conditional `if` attributes are evaluated and marked for inclusion or exclusion.

5. **Variable Substitution**: All variable placeholders in the XML elements are replaced with their corresponding values from the `varSubDict`.

6. **Processing Source Files**: The source files are identified, and specific compiler flags and include paths are set up for each file.

7. **Compilation**: Each source file is compiled with the appropriate flags and options. Dependency files are generated, and timestamp files (`.mtime`) are updated.

8. **Linking and Artifact Creation**: If required, the compiled object files are linked to create the final executable or library artifact.

9. **Postbuild Operations**: Any postbuild operations defined in the configuration are executed.

10. **Cleanup and Exit**: The application cleans up and exits, returning an appropriate status code based on the success or failure of the build process.

## XML Configuration

The XML configuration file defines the structure of the project and includes elements such as:

- **`<dict>`**: Key-value pairs for variable substitutions.
- **`<configuration>`**: Specifies build configurations like `Debug` or `Release`.
- **`<toolchain>`**: Defines toolchain settings like compiler paths and prefixes.
- **`<includes>`**: Include paths for the compiler.
- **`<sources>`**: List of source files to be compiled.
- **`<objects>`**: Object files to be linked.
- **`<pre_op>` and `<post_op>`**: Commands to be executed before or after the build process.

### Example XML Configuration

```xml
<project artifact="myProject" type="executable">
    <dict key="target">x86</dict>
    <configuration name="Debug">
        <optimization>-O0</optimization>
        <debugging>-g3</debugging>
        <toolchain>gcc</toolchain>
        <includes>
            <path>include</path>
        </includes>
    </configuration>
    <toolchain name="gcc">
        <compilerPath>/usr/bin</compilerPath>
        <compilerPrefix>gcc-</compilerPrefix>
        <cflag>-Wall</cflag>
    </toolchain>
    <sources>
        <file path="src/main.c"/>
    </sources>
</project>
```

## Command-Line Options

- **`-v, --version`**: Displays the version number of the application.
- **`-c, --clean`**: Cleans the build directories before starting the build.
- **`-p, --prebuild`**: Executes recursive pyMake on prebuild projects before building the main project.
- **`-f, --file`**: Specifies the XML configuration file to use. Default is `pyMake.xml`.
- **`-g, --cfg`**: Specifies the build configuration to use. Default is `Release`.
- **`-o, --one`**: Compiles a single source file.
- **`-s, --sub`**: Specifies variable substitutions as key-value pairs.
- **`-i, --inc`**: Includes additional XML `<dicts>` files for variable substitution.
- **`-x, --xml`**: Prints intermediate XML files generated during processing.

## Variable Substitution and Conditional Logic

- **Variable Substitution**: The application uses the `varSubDict` dictionary to replace `{key}` patterns in XML elements. This allows for dynamic configuration based on command-line inputs and XML `<dict>` elements.
  
- **Conditional Logic**: The `if` attribute in XML elements allows for conditional inclusion based on variable values. Logical expressions using `;and;` and `;or;` can be used, and grouping with parentheses is supported.

## Error Handling

The application uses the `gError` global variable and exceptions to manage errors. If a critical error is encountered, the build process is halted, and an appropriate message is displayed.

## Extending the Application

To extend the functionality of `pyMake`, you can:

1. **Add New Command-Line Options**: Modify the `argparse` setup to include new options.
2. **Modify XML Structure**: Add new XML elements and update parsing functions to handle them.
3. **Implement Additional Build Steps**: Add new functions or methods to the `Build` class to perform additional tasks during the build process.

## Examples

1. **Basic Build**:
    ```bash
    pyMake.py --file myConfig.xml --cfg Debug
    ```

2. **Clean and Rebuild**:
    ```bash
    pyMake.py --clean
    ```

3. **Compile a Single File**:
    ```bash
    pyMake.py --one main

.c
    ```

4. **Use Additional Substitutions**:
    ```bash
    pyMake.py --sub target:arm --sub build:fast
    ```

## Conclusion

The `pyMake` application is a powerful and flexible tool for automating the build process of complex projects. By leveraging XML configurations and advanced variable substitution, it allows for fine-grained control over compilation and linking steps. Understanding its structure and workflow enables users to customize and extend its functionality to meet specific project requirements.

For any further inquiries or issues, please refer to the application documentation or contact the project maintainer.

--- 

This document provides a detailed understanding of the `pyMake` application, including how it works, its components, and how to use and extend it. Let me know if you'd like to include any additional details or modifications!
